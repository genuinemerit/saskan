#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
:module:    bow_creds_api

REST services for handling IO for credentials-related tasks.
API services for Data Management

Returns data packages only (JSON headers and body), no HTML or JavaScript
Don't expect to have a GUI in front on this, except maybe for analysis and monitoring.
Should be called only by other BoW APIs.
Otherwise, test from command line using HTTPIE or CURL

Assumes credentials are available for:
- admin.genuinemerit.org   56090:56099
at
/etc/letsencrypt/live/auth.genuinemerit.org

Maybe eventually we'll want to change cname to 'data'

:author:    GM <genuinemerit@protonmail.com>

@DEV:
Reading ods files is available natively in pandas 0.25. So long as you have odfpy installed you can do
This is likely more relevant in the bow_data/model layer.. just making a note of it here.

``pd.read_excel("the_document.ods", engine="odf")``
"""
import json
import logging
import math
import requests
import time
import os
import sys
import jinja2
from pprint import pprint as pp
from tornado import httpserver, web, ioloop
from tornado.options import define, options
from flask_api import status
from tornado_jinja2 import Jinja2Loader
from bow_data.logger import logger  # pylint: disable=import-error
from bow_data.func_basic import FuncBasic  # pylint: disable=import-error

class CredsConstants(object):
    """
    Provide strings used across multiple classes and methods
    """
    def __init__(self):
        """
        Define commonly used strings
        """
        self.header_requests = {
            'Host': 'Host domain name:port number',
            'X-BoW-API-Token': 'Encrypted credentials key for the calling system',
            'X-BoW-Session-ID': 'Encrypted session key for the calling system',
            'X-BoW-Internal-IP': 'Internal IP of the caller if available',
            'X-BoW-Request-ID': 'Generated by the BoW server. Provides a unique ID for every request.',
            'WWW-Authenticate': 'BoW'
        }
        self.header_responses = {
            '200':'Success, data found or activity completed',
            '204':'Well-formed request but no data found',
            '400': 'Bad request',
            '403': 'Denied, user lacks permission',
            '406': 'Bad data content in request',
            '409': 'Conflict, try later' }

        self.request_desc = {
            'info': "Generic info about setting and retrieving credentials.",
            'get': "Get information about a specified credential.",
            'delete': "Remove a specified credential.",
            'put': "Set up credentials based on attributes provided." }

        """
        To set up some secrets we need:

        Key to look up / ID credentials secrets:
        - app-name                  like 'bow_char'
        - internal IP               like '10.132.105.225'       (may be multiples)
        - valid Host range          like  '56060:56069'         (probably store as a list)
        - service-call-verb+path    like  ['GET', 'places/id']  (may be multiples of these)
        """
        self.setup_request_body =  {
            "app_name":             "name of requesting application",
            "port_range":           "ports assigned to this app",
            "cred_req":  "list of 1 to n groups with 'method', 'app', 'path' keys" }

        self.retrieval_request_body =  {
            "secret":               "value to be used for requesting these permission" }

        self.setup_response_body = {
            "alert":            "processing message",
            "serv_key":         "confirmation of cred_req",
            "secret":           "value to be used for requesting these permission" }

        self.retrieval_response_body = {
            "alert":            "confirmation message" }

        self.v_0_1_meta_paths = {'v0.1': [
            [["GET"], ["/orch/key/info"],   "Describe how to handle authorization set-up requests"],
            [["GET"], ["/orch/get"],        "Describe how to retrieve info about an authorization set-up"],
            [["GET"], ["/orch/delete"],     "Describe how to remove an authorization set-up"],
            [["GET"], ["/orch/put"],        "Describe how to create an authorization set-up"] ] }

        self.v_0_1_active_paths = {'v0.1': [
            [["GET", "DELETE"], ["/orch/key"], ["retrieval request package"], "Retrieve or delete credentials"],
            [["PUT"],           ["/orch/key"], ["setup request package"], "Add credentials"] ] }

class AppException(web.HTTPError):
    """
    Use flask_api.status codes instead of Tornado's web.HTTPError.
    """
    pass

class CredsMeta(web.RequestHandler):
    """
    Handle metadata requests
    """
    def data_received(self, chunk):
        pass

    def head(self, *args, **kwargs):
        """
        Request:  HEAD is available for all valid URL paths
        """
        pass

    def get(self, *args, **kwargs):
        """
        Request: GET <meta>: (alternative to OPTIONS)
        """
        meta_topic = self.request.uri.split('/')[3]
        pp(self.request.uri)
        meta_msg = {'meta': {'topic': meta_topic,
                             'path':self.request.uri },
                 'request': {'desc': CC.request_desc[meta_topic],
                             'headers': CC.header_requests,
                             'paths': None,
                             'verbs': None,
                             'body': None },
                'response': {'headers': CC.header_responses,
                             'body': None} }
        if meta_topic == 'info':
            meta_msg['request']['paths'] = {
                'meta': {'v0.1': CC.v_0_1_meta_paths},
                'active': {'v0.1': CC.v_0_1_active_paths} }
            meta_msg['response'] = None
        else:
            meta_msg['request']['paths'] = ['admin/creds']
            if meta_topic == 'get':
                meta_msg['request']['verbs'] = ['GET']
                meta_msg['request']['body'] = CC.retrieval_request_body
                meta_msg['response']['body'] = CC.retrieval_request_body
            elif meta_topic == 'delete':
                meta_msg['request']['verbs'] = ['DELETE']
                meta_msg['request']['body'] = CC.retrieval_request_body
                meta_msg['response']['body'] = CC.retrieval_request_body
            elif meta_topic == 'put':
                meta_msg['request']['verbs'] = ['PUT']
                meta_msg['request']['body'] = CC.setup_request_body
                meta_msg['response']['body'] = CC.setup_request_body

        self.write(json.dumps(meta_msg))

class Creds(web.RequestHandler):
    """
    Handle API calls for auth-related services
        - key (credentials)

    """
    def data_received(self, chunk):
        pass

    def head(self, *args, **kwargs):
        """
        Request:
            HEAD is available for all valid URL paths
        """
        pass

    def format_fail_reply(self, status_code, alert):
        """
        Handle a "bad request" reply

        :Attr:
          {constant}  flask_api HTTP response code identifier
          {string}    Message to pass along with the 406 code
        """
        err_out = dict()
        err_out["Request"] = [self.request.method, self.request.uri]
        err_out["Response"] = [status_code, alert]
        self.set_status(status_code, reason=alert)
        return(json.dumps(err_out))

    def put(self, *args, **kwargs):
        """
        Request - [["PUT"], ["/creds/key"], ["setup request package"], "Add credentials"]
            header:
                'Host': {}               Domain name:port number
                'WWW-Authenticate': {}   Must be 'BoW'
            body:
                "app_name": {}           Name of requesting app
                "port_range": {}         Ports assigned to requesting app
                "cred_req":               List of permissions being requested for that app
                    [{"method": {}, "app": {}, "path": {}}, .. ]
        Process:
               We don't do so much checking in this layer. Assume caller has already done that.
            1) Formulate and send request to bow_data/model
            2) Handle response from bow_data/api
            3) Formulate and write reply
        Reponse body:
            get and delete:
                "alert":    Confirmation message only
            put:
                "alert":    Processing message
                "serv_key": Confirmation of cred_req
                "secret":   Value to be used for requesting these permissions from this app
        """
        def request_data_model():
            """
            Send request to bow_data/model

            Port range:   56090:56099
            """
            request_header = {'key': 'value'}
            request_data = {'key': 'value'}
            response_header = ''
            response_body = ''
            response = requests.put("https://admin.genuinemerit.org/creds/model",
                                    headers=request_header,
                                    data=request_data,
                                    verify=True)
            status_code = response.status_code
            alert = ''
            pp(response.status_code)
            return (status_code, alert, response_header, response_body)

        def format_put_reply():
            """
            Assemble response to completed put request
            """
            response = ''
            return response

        status_code, alert, _, _ = request_data_model()
        if status_code == 200:
            self.write(format_put_reply())
        else:
            if status_code == 400:
                self.write(self.format_fail_reply(status.HTTP_400_BAD_REQUEST, alert))
            elif status_code == 406:
                self.write(self.format_fail_reply(status.HTTP_406_NOT_ACCEPTABLE, alert))
            elif status_code < 500:
                self.write(self.format_fail_reply(status_code, 'Client Error'))
            else:
                self.write(self.format_fail_reply(status_code, 'Server Error'))

    def delete(self, *args, **kwargs):
        """
        Request:

        """
        pass

    def get(self, *args, **kwargs):
        """
        Request:

        """
        pass

class Robots(web.RequestHandler):
    """
    GET /robots.txt
    """
    def data_received(self, chunk):
        pass

    def get(self, *args, **kwargs):
        """ Write robots.txt content to body """
        with open(options.static + '/robots.txt', 'r') as robot_f:
            self.write(robot_f.read())

class Unknown(web.RequestHandler):
    """
    Service of last resort...
    """
    def data_received(self, chunk):
        pass

    def get(self, *args, **kwargs):
        """
        Capture all other error displays.
        """
        status_code = status.HTTP_400_BAD_REQUEST
        alert = 'Unknown request'
        err_out = dict()
        err_out["Request"] = [self.request.method, self.request.uri]
        err_out["Response"] = [status_code, alert]
        self.set_status(status_code, reason=alert)
        self.write(json.dumps(err_out))

## main
#####################

def main():
    """
    Point to templates directory for (HTML) rendering.
    Point to static directory for js, img, other static resources.
    Set debug level.
    Define URL handlers.
    Define security level.
    Point to SSL certificates.
    Start listening on designated ports.
    Launch the Creds services.
    """
    debug_jinja = True if options.log_level == 'DEBUG' else False
    settings = dict(debug=debug_jinja)
    """
    settings = dict(template_loader=jinja2_loader,
                    static_path=os.path.join(os.path.dirname(__file__), options.dir_static),
                    debug=debug_jinja)
    """
    app = web.Application(
        handlers=[
            (r"{}/creds/info".format(options.app_url_root), CredsMeta),
            (r"{}/creds/get".format(options.app_url_root), CredsMeta),
            (r"{}/creds/delete".format(options.app_url_root), CredsMeta),
            (r"{}/creds/put".format(options.app_url_root), CredsMeta),

            (r"{}/creds".format(options.app_url_root), Creds),

            (r"/robots.txt", Robots),
            (r"/(.*)", Unknown)],
        **settings
    )
    ## For now using an existing domain/cert (admin.genuinemerit.org):
    http_server = httpserver.HTTPServer(app, ssl_options={
        "certfile": "/etc/letsencrypt/live/" + options.app_cname + "." + options.host_domain + "/fullchain.pem",
        "keyfile": "/etc/letsencrypt/live/" + options.app_cname + "." + options.host_domain + "/privkey.pem",
    })

    for port in PORTS:
        http_server.listen(port)    # can have multiple listen() statements, one for each port. Works fine.
    ioloop.IOLoop.instance().start()

if __name__ == "__main__":
    """
    Define, collect options from command line, from config file.
    Config file location passed in as a cmd line option.
    """
    CC = CredsConstants()
    FB = FuncBasic()
    define_options = ['host_domain', 'app_cname', 'app_ports', 'app_url_root']
    for item in define_options:
        define(item)
    conf_file = os.path.join(os.path.dirname(__file__), '../model/bow_data.conf')
    options.parse_config_file(conf_file)
    PORTS = FB.list_ports(options.app_ports)
    LOG = logger()
    LOG.set_logs()
    main()
